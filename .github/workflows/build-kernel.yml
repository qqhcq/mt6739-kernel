name: Build MT6739 Kernel (Power535) with ACM Support

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

env:
  TOOLCHAIN_VERSION: gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu
  KERNEL_ARCH: arm64
  DEFCONFIG: k39tv1_64_bsp_defconfig

jobs:
  build:
    runs-on: ubuntu-20.04
    timeout-minutes: 120
    
    steps:
    - name: 📊 显示系统信息
      run: |
        echo "=== 系统信息 ==="
        uname -a
        echo "=== CPU 信息 ==="
        nproc
        echo "=== 内存信息 ==="
        free -h
        echo "=== 磁盘空间（清理前）==="
        df -h
        
    - name: 🧹 最大化构建空间
      run: |
        echo "正在清理不必要的文件..."
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /opt/ghc
        sudo rm -rf /usr/local/share/boost
        sudo rm -rf "$AGENT_TOOLSDIRECTORY"
        sudo apt-get clean
        echo "=== 磁盘空间（清理后）==="
        df -h
        
    - name: 📥 克隆 Kernel 源码
      run: |
        echo "正在克隆 MT6739 内核源码（Power535 版本）..."
        git clone --depth=1 https://github.com/Power535/android_kernel_common_MT6763.git kernel-src
        cd kernel-src
        echo "✅ 源码克隆完成"
        echo "=== 源码目录结构 ==="
        ls -lah
        echo "=== 内核版本信息 ==="
        head -n 5 Makefile
        echo "=== 检查可用的 defconfig ==="
        find arch/arm64/configs -name "*6739*" -o -name "*6763*" | head -20
        
    - name: 🔧 安装编译依赖
      run: |
        echo "正在安装编译依赖..."
        sudo apt-get update -qq
        sudo apt-get install -y \
          build-essential \
          bc \
          bison \
          flex \
          libssl-dev \
          libncurses-dev \
          python3 \
          python3-pip \
          python-is-python3 \
          u-boot-tools \
          device-tree-compiler \
          lz4 \
          lzop \
          zip \
          unzip
        
        # 显示 OpenSSL 版本（ubuntu-20.04 自带 OpenSSL 1.1，完美兼容老内核）
        openssl version
        echo "✅ 依赖安装完成"
        
    - name: 💾 缓存交叉编译工具链
      id: cache-toolchain
      uses: actions/cache@v4
      with:
        path: ${{ env.TOOLCHAIN_VERSION }}
        key: ${{ runner.os }}-toolchain-${{ env.TOOLCHAIN_VERSION }}
        
    - name: 📦 下载交叉编译工具链
      if: steps.cache-toolchain.outputs.cache-hit != 'true'
      run: |
        echo "正在下载 Linaro GCC 7.5 工具链..."
        TOOLCHAIN_URL="https://releases.linaro.org/components/toolchain/binaries/7.5-2019.12/aarch64-linux-gnu/${TOOLCHAIN_VERSION}.tar.xz"
        
        if wget --spider "$TOOLCHAIN_URL" 2>/dev/null; then
          wget --progress=dot:giga "$TOOLCHAIN_URL"
          echo "✅ 工具链下载完成"
        else
          echo "❌ 工具链下载失败"
          exit 1
        fi
        
    - name: 📂 解压工具链
      if: steps.cache-toolchain.outputs.cache-hit != 'true'
      run: |
        echo "正在解压工具链..."
        tar -xf ${TOOLCHAIN_VERSION}.tar.xz
        echo "✅ 工具链解压完成"
        
    - name: 🔍 验证工具链
      run: |
        export PATH=$PWD/${TOOLCHAIN_VERSION}/bin:$PATH
        echo "TOOLCHAIN_PATH=$PWD/${TOOLCHAIN_VERSION}/bin/aarch64-linux-gnu-" >> $GITHUB_ENV
        
        echo "=== 工具链信息 ==="
        ${TOOLCHAIN_VERSION}/bin/aarch64-linux-gnu-gcc --version
        echo "✅ 工具链验证成功"
        
    - name: 🐍 修复 Python 2/3 兼容性和权限
      run: |
        cd kernel-src
        
        echo "=== 修复 Python 兼容性和权限问题 ==="
        
        # 1. 修复 tools/dct/DrvGen.py（Python 3 兼容性 + 执行权限）
        if [ -f "tools/dct/DrvGen.py" ]; then
          echo "修复 tools/dct/DrvGen.py..."
          
          # 修复 Python 2 到 Python 3 的语法
          sed -i '1s|^#!/usr/bin/python.*|#!/usr/bin/env python3|' tools/dct/DrvGen.py
          sed -i 's/print /print(/g; s/^\([^#]*\)print(\(.*\))$/\1print(\2)/g' tools/dct/DrvGen.py
          
          # 添加执行权限
          chmod +x tools/dct/DrvGen.py
          
          echo "✅ DrvGen.py 修复完成（语法 + 权限）"
        else
          echo "ℹ️ 未找到 DrvGen.py，跳过"
        fi
        
        # 2. 修复 drvgen.mk，让它使用 python3 执行
        if [ -f "scripts/drvgen/drvgen.mk" ]; then
          echo "修复 scripts/drvgen/drvgen.mk..."
          # 将 ./tools/dct/DrvGen.py 替换为 python3 tools/dct/DrvGen.py
          sed -i 's|\./tools/dct/DrvGen\.py|python3 tools/dct/DrvGen.py|g' scripts/drvgen/drvgen.mk
          echo "✅ drvgen.mk 修复完成"
        else
          echo "ℹ️ 未找到 drvgen.mk，跳过"
        fi
        
        # 3. 给所有 Python 脚本添加执行权限
        echo "添加 Python 脚本执行权限..."
        find tools -name "*.py" -exec chmod +x {} \; 2>/dev/null || true
        find scripts -name "*.py" -exec chmod +x {} \; 2>/dev/null || true
        echo "✅ Python 脚本权限设置完成"
        
        # 4. 修复 DTC yylloc 重复定义问题
        if [ -f "scripts/dtc/dtc-lexer.lex.c" ]; then
          echo "修复 DTC yylloc 重复定义..."
          sed -i 's/^YYLTYPE yylloc;$/extern YYLTYPE yylloc;/' scripts/dtc/dtc-lexer.lex.c
          echo "✅ DTC yylloc 修复完成"
        else
          echo "ℹ️ 未找到 dtc-lexer.lex.c，跳过"
        fi
        
        echo ""
        echo "✅ 所有兼容性和权限问题修复完成"
        
    - name: ⚙️ 配置 Kernel
      run: |
        cd kernel-src
        
        # 查找可用的 MT6739 defconfig
        echo "=== 查找 MT6739 相关配置 ==="
        AVAILABLE_CONFIGS=$(find arch/arm64/configs -name "*6739*" -o -name "*6763*" | head -10)
        echo "找到的配置文件："
        echo "$AVAILABLE_CONFIGS"
        
        # 优先使用 MT6739 的配置，否则使用 MT6763 的
        MT6739_CONFIG=$(find arch/arm64/configs -name "*6739*" | head -1)
        if [ -n "$MT6739_CONFIG" ]; then
          DEFCONFIG=$(basename "$MT6739_CONFIG")
          echo "✅ 使用 MT6739 专用配置: ${DEFCONFIG}"
        else
          # 尝试使用 MT6763 配置
          MT6763_CONFIG=$(find arch/arm64/configs -name "*6763*" | head -1)
          if [ -n "$MT6763_CONFIG" ]; then
            DEFCONFIG=$(basename "$MT6763_CONFIG")
            echo "⚠️ 使用 MT6763 配置: ${DEFCONFIG}"
          else
            # 使用环境变量中的默认配置
            echo "⚠️ 使用默认配置: ${DEFCONFIG}"
          fi
        fi
        
        echo "=== 应用配置: ${DEFCONFIG} ==="
        make ARCH=${KERNEL_ARCH} CROSS_COMPILE=${{ env.TOOLCHAIN_PATH }} ${DEFCONFIG}
        
        echo "=== 应用旧配置选项 ==="
        # 使用非交互式配置，自动选择默认值
        yes "" | make ARCH=${KERNEL_ARCH} CROSS_COMPILE=${{ env.TOOLCHAIN_PATH }} oldconfig 2>&1 | head -n 50
        
        echo "✅ 内核配置完成"
        
        # 启用 USB ACM 串口支持 - 直接修改 .config 文件
        echo "=== 启用 USB 串口支持 ==="
        
        # 备份原始配置
        cp .config .config.backup
        
        # 定义需要启用的配置选项
        USB_CONFIGS=(
          "CONFIG_USB_GADGET"
          "CONFIG_USB_CONFIGFS"
          "CONFIG_USB_F_ACM"
          "CONFIG_USB_F_SERIAL"
          "CONFIG_USB_G_SERIAL"
          "CONFIG_USB_SERIAL"
          "CONFIG_USB_ACM"
          "CONFIG_USB_F_OBEX"
          "CONFIG_USB_F_MTP"
          "CONFIG_USB_CONFIGFS_SERIAL"
          "CONFIG_USB_CONFIGFS_ACM"
          "CONFIG_USB_CONFIGFS_OBEX"
          "CONFIG_USB_CONFIGFS_F_FS"
          "CONFIG_USB_CONFIGFS_F_MTP"
          "CONFIG_USB_CONFIGFS_F_ACC"
        )
        
        # 启用所有 USB 串口相关配置
        for config in "${USB_CONFIGS[@]}"; do
          # 如果配置项存在但未启用，则启用它
          if grep -q "^# ${config} is not set" .config; then
            sed -i "s/^# ${config} is not set/${config}=y/" .config
            echo "✅ 启用: ${config}"
          elif grep -q "^${config}=" .config; then
            # 确保是 =y 而不是 =m
            sed -i "s/^${config}=.*/${config}=y/" .config
            echo "✅ 已存在: ${config}"
          else
            # 配置项不存在，直接添加
            echo "${config}=y" >> .config
            echo "➕ 添加: ${config}"
          fi
        done
        
        # 重新生成配置，使依赖关系正确
        echo "=== 重新生成配置 ==="
        yes "" | make ARCH=${KERNEL_ARCH} CROSS_COMPILE=${{ env.TOOLCHAIN_PATH }} oldconfig 2>&1 | head -n 30 || true
        
        # 显示关键配置选项
        echo ""
        echo "=== 最终配置检查 ==="
        grep -E "CONFIG_USB_ACM|CONFIG_USB_GADGET|CONFIG_USB_CONFIGFS|CONFIG_USB_F_ACM|CONFIG_USB_SERIAL" .config | head -20 || echo "⚠️ 注意: 某些 USB 配置可能未启用"
        
    - name: 🔨 编译 Kernel
      run: |
        cd kernel-src
        
        echo "=== 开始编译内核 ==="
        echo "使用 $(nproc) 个 CPU 核心并行编译"
        echo "开始时间: $(date)"
        
        # 确保日志文件存在
        touch build.log
        
        # 设置编译参数
        export ARCH=${KERNEL_ARCH}
        export CROSS_COMPILE=${{ env.TOOLCHAIN_PATH }}
        
        # 忽略 OpenSSL 废弃警告（兼容 OpenSSL 3.0）
        export KCFLAGS="-Wno-deprecated-declarations -Wno-error=deprecated-declarations"
        export HOSTCFLAGS="-Wno-deprecated-declarations -Wno-error=deprecated-declarations"
        
        # 修复 Makefile 中的 OpenSSL 编译选项
        if grep -q "scripts/extract-cert" Makefile; then
          echo "修复 Makefile 的 OpenSSL 编译选项..."
          sed -i '/HOSTCFLAGS_extract-cert/d' scripts/Makefile
          echo 'HOSTCFLAGS_extract-cert.o = -Wno-deprecated-declarations' >> scripts/Makefile
          echo "✅ OpenSSL 编译选项修复完成"
        fi
        
        BUILD_SUCCESS=false
        
        # 尝试编译 Image.gz-dtb（最理想的格式：压缩内核+设备树）
        echo ""
        echo ">>> 尝试编译 Image.gz-dtb..."
        if make -j$(nproc) Image.gz-dtb 2>&1 | tee build.log; then
          echo "✅ Image.gz-dtb 编译成功！"
          BUILD_SUCCESS=true
          KERNEL_TARGET="Image.gz-dtb"
        else
          echo "⚠️ Image.gz-dtb 编译失败（可能此内核不支持 dtb），尝试 Image..."
          
          # 不清理，直接尝试编译 Image（未压缩内核）
          echo ""
          echo ">>> 尝试编译 Image..."
          if make -j$(nproc) Image 2>&1 | tee -a build.log; then
            echo "✅ Image 编译成功！"
            BUILD_SUCCESS=true
            KERNEL_TARGET="Image"
          else
            echo "❌ Image 编译也失败了，尝试最基础的 vmlinux..."
            
            # 最后尝试只编译内核本身（最基础格式）
            echo ""
            echo ">>> 最后尝试编译 vmlinux..."
            if make -j$(nproc) vmlinux 2>&1 | tee -a build.log; then
              echo "✅ vmlinux 编译成功（需要后续处理）"
              BUILD_SUCCESS=true
              KERNEL_TARGET="vmlinux"
            else
              echo "❌ 所有编译尝试都失败了"
              BUILD_SUCCESS=false
            fi
          fi
        fi
        
        echo ""
        echo "结束时间: $(date)"
        echo "编译目标: ${KERNEL_TARGET:-无}"
        
        if [ "$BUILD_SUCCESS" != "true" ]; then
          echo ""
          echo "=== 编译错误日志（最后 200 行）==="
          tail -n 200 build.log
          exit 1
        fi
        
    - name: ✅ 检查编译产物
      run: |
        cd kernel-src
        
        echo "=== 检查编译结果 ==="
        
        KERNEL_FOUND=false
        
        # 按优先级检查内核文件
        if [ -f arch/arm64/boot/Image.gz-dtb ]; then
          echo "✅ 找到 Image.gz-dtb (最佳选择)"
          ls -lh arch/arm64/boot/Image.gz-dtb
          cp arch/arm64/boot/Image.gz-dtb kernel_image
          KERNEL_FOUND=true
          echo "KERNEL_TYPE=Image.gz-dtb" >> $GITHUB_ENV
          
        elif [ -f arch/arm64/boot/Image.gz ]; then
          echo "✅ 找到 Image.gz"
          ls -lh arch/arm64/boot/Image.gz
          cp arch/arm64/boot/Image.gz kernel_image
          KERNEL_FOUND=true
          echo "KERNEL_TYPE=Image.gz" >> $GITHUB_ENV
          
        elif [ -f arch/arm64/boot/Image ]; then
          echo "✅ 找到 Image"
          ls -lh arch/arm64/boot/Image
          cp arch/arm64/boot/Image kernel_image
          KERNEL_FOUND=true
          echo "KERNEL_TYPE=Image" >> $GITHUB_ENV
          
        elif [ -f vmlinux ]; then
          echo "⚠️ 只找到 vmlinux (需要进一步处理)"
          ls -lh vmlinux
          cp vmlinux kernel_image
          KERNEL_FOUND=true
          echo "KERNEL_TYPE=vmlinux" >> $GITHUB_ENV
        fi
        
        if [ "$KERNEL_FOUND" != "true" ]; then
          echo "❌ 未找到任何内核文件"
          echo "=== 检查 boot 目录 ==="
          ls -lR arch/arm64/boot/ || true
          echo "=== 编译日志（最后 100 行）==="
          tail -n 100 build.log
          exit 1
        fi
        
        # 计算文件哈希
        echo "=== 内核文件信息 ==="
        file kernel_image
        sha256sum kernel_image
        
    - name: 📤 上传 Kernel 镜像
      uses: actions/upload-artifact@v4
      with:
        name: mt6739-kernel-acm-${{ env.KERNEL_TYPE }}
        path: kernel-src/kernel_image
        retention-days: 30
        compression-level: 0
        
    - name: 📋 上传编译日志
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: build-log-${{ github.run_number }}
        path: kernel-src/build.log
        retention-days: 7
        
    - name: 📊 生成构建摘要
      if: always()
      run: |
        cd kernel-src
        
        echo "## 🔧 MT6739 内核编译摘要" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**构建编号:** ${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
        echo "**提交 SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**分支:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ -f "kernel_image" ]; then
          echo "### ✅ 编译成功" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**内核类型:** \`${KERNEL_TYPE:-未知}\`" >> $GITHUB_STEP_SUMMARY
          echo "**文件大小:** $(du -h kernel_image | cut -f1)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📦 下载" >> $GITHUB_STEP_SUMMARY
          echo "在 Actions 页面的 Artifacts 中下载编译好的内核" >> $GITHUB_STEP_SUMMARY
        else
          echo "### ❌ 编译失败" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "请查看构建日志了解详情" >> $GITHUB_STEP_SUMMARY
        fi
        
    - name: 🎉 创建 Release
      if: success() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && github.event_name == 'push'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v1.0-power535-build-${{ github.run_number }}
        name: MT6739 Kernel (Power535/MT6763) with ACM - Build ${{ github.run_number }}
        body: |
          ## 📱 MT6739 Kernel (Power535 版本) with USB ACM Support
          
          > 基于 Power535/android_kernel_common_MT6763 仓库编译
          > 支持 MT6580/MT6737/MT6739/MT6750/MT6757c/MT6761/MT6762/MT6763
          
          ### 📋 构建信息
          - **构建编号:** ${{ github.run_number }}
          - **构建时间:** ${{ github.event.head_commit.timestamp }}
          - **提交 SHA:** `${{ github.sha }}`
          - **内核类型:** `${{ env.KERNEL_TYPE }}`
          
          ### ✨ 主要特性
          - ✅ **USB ACM (Serial) Support** - 支持 USB 串口通信
          - ✅ **USB ADB Support** - Android 调试桥支持
          - ✅ **USB MTP Support** - 媒体传输协议支持
          - ✅ **USB Gadget** - USB 设备模式支持
          
          ### 🔧 适用设备
          - MT6739 芯片组设备
          - TCL 5059D 及同类设备
          - 和对讲 D22 对讲机
          
          ### 📖 使用方法
          
          #### 方法一：使用 AIK (Android Image Kitchen)
          ```bash
          # 1. 解包原 boot.img
          ./unpackimg.sh boot.img
          
          # 2. 替换内核
          cp kernel_image split_img/boot.img-kernel
          
          # 3. 重新打包
          ./repackimg.sh
          
          # 4. 刷入设备
          fastboot flash boot image-new.img
          ```
          
          #### 方法二：使用 Magisk
          ```bash
          # 1. 在 Magisk Manager 中选择安装
          # 2. 选择并修补 boot.img
          # 3. 刷入修补后的镜像
          ```
          
          ### ⚠️ 注意事项
          - 刷机前请备份原 boot.img
          - 确认设备型号匹配
          - 建议在 recovery 模式下刷入
          - 首次刷入可能需要清除缓存
          
          ### 🔗 相关链接
          - [源码仓库](https://github.com/Power535/android_kernel_common_MT6763)
          - [构建日志](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
          
          ---
          
          **自动构建于 GitHub Actions** 🤖
          
        files: kernel-src/kernel_image
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
